// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace mprs {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class BackoffDuration;
class LogLine;
class LogLines;
class MachinePortLock;
class MprsInstanceID;
class MprsWorker;
class NodeResources;
class Resource;
class RunningTask;
class SchedulerHeartbeatResponse;
class ServiceAddress;

enum KillMethod {
  UnusedKillMethod = 0,
  SOFT = 1,
  HEAD = 2,
  KillMethod_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  KillMethod_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool KillMethod_IsValid(int value);
const KillMethod KillMethod_MIN = UnusedKillMethod;
const KillMethod KillMethod_MAX = HEAD;
const int KillMethod_ARRAYSIZE = KillMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* KillMethod_descriptor();
inline const ::std::string& KillMethod_Name(KillMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    KillMethod_descriptor(), value);
}
inline bool KillMethod_Parse(
    const ::std::string& name, KillMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KillMethod>(
    KillMethod_descriptor(), name, value);
}
enum KilledTaskStatusFilter {
  UnusedKilledTaskStatusFilter = 0,
  NONE = 1,
  FORCE_DONE_OR_FAILED = 2,
  FORCE_DONE_OR_INCOMPLETE_BACKOFF = 3,
  FORCE_DONE_OR_INCOMPLETE = 4,
  KilledTaskStatusFilter_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  KilledTaskStatusFilter_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool KilledTaskStatusFilter_IsValid(int value);
const KilledTaskStatusFilter KilledTaskStatusFilter_MIN = UnusedKilledTaskStatusFilter;
const KilledTaskStatusFilter KilledTaskStatusFilter_MAX = FORCE_DONE_OR_INCOMPLETE;
const int KilledTaskStatusFilter_ARRAYSIZE = KilledTaskStatusFilter_MAX + 1;

const ::google::protobuf::EnumDescriptor* KilledTaskStatusFilter_descriptor();
inline const ::std::string& KilledTaskStatusFilter_Name(KilledTaskStatusFilter value) {
  return ::google::protobuf::internal::NameOfEnum(
    KilledTaskStatusFilter_descriptor(), value);
}
inline bool KilledTaskStatusFilter_Parse(
    const ::std::string& name, KilledTaskStatusFilter* value) {
  return ::google::protobuf::internal::ParseNamedEnum<KilledTaskStatusFilter>(
    KilledTaskStatusFilter_descriptor(), name, value);
}
enum MprsTaskStatusBits {
  UnusedMprsTaskStatusBits = 0,
  UNSTARTED = 1,
  RUNNING = 2,
  DONE = 4,
  INCOMPLETE = 8,
  FAILED = 16,
  ERROR = 32,
  USES_BACKOFF = 64,
  DOES_NOT_ADVANCE_BACKOFF = 512,
  OVERWRITEABLE = 1024,
  CURRENT_STATUS_MASK = 1663,
  AVOIDED = 128,
  DISABLED = 256,
  CAN_RUN_MASK = 384,
  MprsTaskStatusBits_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MprsTaskStatusBits_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MprsTaskStatusBits_IsValid(int value);
const MprsTaskStatusBits MprsTaskStatusBits_MIN = UnusedMprsTaskStatusBits;
const MprsTaskStatusBits MprsTaskStatusBits_MAX = CURRENT_STATUS_MASK;
const int MprsTaskStatusBits_ARRAYSIZE = MprsTaskStatusBits_MAX + 1;

const ::google::protobuf::EnumDescriptor* MprsTaskStatusBits_descriptor();
inline const ::std::string& MprsTaskStatusBits_Name(MprsTaskStatusBits value) {
  return ::google::protobuf::internal::NameOfEnum(
    MprsTaskStatusBits_descriptor(), value);
}
inline bool MprsTaskStatusBits_Parse(
    const ::std::string& name, MprsTaskStatusBits* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MprsTaskStatusBits>(
    MprsTaskStatusBits_descriptor(), name, value);
}
// ===================================================================

class BackoffDuration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.BackoffDuration) */ {
 public:
  BackoffDuration();
  virtual ~BackoffDuration();

  BackoffDuration(const BackoffDuration& from);

  inline BackoffDuration& operator=(const BackoffDuration& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BackoffDuration& default_instance();

  void Swap(BackoffDuration* other);

  // implements Message ----------------------------------------------

  inline BackoffDuration* New() const { return New(NULL); }

  BackoffDuration* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BackoffDuration& from);
  void MergeFrom(const BackoffDuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BackoffDuration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool no_more_backoffs = 1;
  void clear_no_more_backoffs();
  static const int kNoMoreBackoffsFieldNumber = 1;
  bool no_more_backoffs() const;
  void set_no_more_backoffs(bool value);

  // optional int32 seconds = 2;
  void clear_seconds();
  static const int kSecondsFieldNumber = 2;
  ::google::protobuf::int32 seconds() const;
  void set_seconds(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mprs.BackoffDuration)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool no_more_backoffs_;
  ::google::protobuf::int32 seconds_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static BackoffDuration* default_instance_;
};
// -------------------------------------------------------------------

class LogLine : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.LogLine) */ {
 public:
  LogLine();
  virtual ~LogLine();

  LogLine(const LogLine& from);

  inline LogLine& operator=(const LogLine& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogLine& default_instance();

  void Swap(LogLine* other);

  // implements Message ----------------------------------------------

  inline LogLine* New() const { return New(NULL); }

  LogLine* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogLine& from);
  void MergeFrom(const LogLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogLine* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  const ::std::string& job_id() const;
  void set_job_id(const ::std::string& value);
  void set_job_id(const char* value);
  void set_job_id(const char* value, size_t size);
  ::std::string* mutable_job_id();
  ::std::string* release_job_id();
  void set_allocated_job_id(::std::string* job_id);

  // optional string node_id = 2;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // optional int32 time = 3;
  void clear_time();
  static const int kTimeFieldNumber = 3;
  ::google::protobuf::int32 time() const;
  void set_time(::google::protobuf::int32 value);

  // optional string line = 4;
  void clear_line();
  static const int kLineFieldNumber = 4;
  const ::std::string& line() const;
  void set_line(const ::std::string& value);
  void set_line(const char* value);
  void set_line(const char* value, size_t size);
  ::std::string* mutable_line();
  ::std::string* release_line();
  void set_allocated_line(::std::string* line);

  // optional int64 line_id = 5;
  void clear_line_id();
  static const int kLineIdFieldNumber = 5;
  ::google::protobuf::int64 line_id() const;
  void set_line_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mprs.LogLine)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr job_id_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::google::protobuf::internal::ArenaStringPtr line_;
  ::google::protobuf::int64 line_id_;
  ::google::protobuf::int32 time_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LogLine* default_instance_;
};
// -------------------------------------------------------------------

class LogLines : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.LogLines) */ {
 public:
  LogLines();
  virtual ~LogLines();

  LogLines(const LogLines& from);

  inline LogLines& operator=(const LogLines& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogLines& default_instance();

  void Swap(LogLines* other);

  // implements Message ----------------------------------------------

  inline LogLines* New() const { return New(NULL); }

  LogLines* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogLines& from);
  void MergeFrom(const LogLines& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogLines* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mprs.LogLine lines = 1;
  int lines_size() const;
  void clear_lines();
  static const int kLinesFieldNumber = 1;
  const ::mprs::LogLine& lines(int index) const;
  ::mprs::LogLine* mutable_lines(int index);
  ::mprs::LogLine* add_lines();
  ::google::protobuf::RepeatedPtrField< ::mprs::LogLine >*
      mutable_lines();
  const ::google::protobuf::RepeatedPtrField< ::mprs::LogLine >&
      lines() const;

  // optional int64 next_line_id = 2;
  void clear_next_line_id();
  static const int kNextLineIdFieldNumber = 2;
  ::google::protobuf::int64 next_line_id() const;
  void set_next_line_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mprs.LogLines)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::mprs::LogLine > lines_;
  ::google::protobuf::int64 next_line_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LogLines* default_instance_;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.Resource) */ {
 public:
  Resource();
  virtual ~Resource();

  Resource(const Resource& from);

  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();

  void Swap(Resource* other);

  // implements Message ----------------------------------------------

  inline Resource* New() const { return New(NULL); }

  Resource* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Resource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int32 amount() const;
  void set_amount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mprs.Resource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 amount_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Resource* default_instance_;
};
// -------------------------------------------------------------------

class NodeResources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.NodeResources) */ {
 public:
  NodeResources();
  virtual ~NodeResources();

  NodeResources(const NodeResources& from);

  inline NodeResources& operator=(const NodeResources& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeResources& default_instance();

  void Swap(NodeResources* other);

  // implements Message ----------------------------------------------

  inline NodeResources* New() const { return New(NULL); }

  NodeResources* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeResources& from);
  void MergeFrom(const NodeResources& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeResources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string node = 1;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::std::string& node() const;
  void set_node(const ::std::string& value);
  void set_node(const char* value);
  void set_node(const char* value, size_t size);
  ::std::string* mutable_node();
  ::std::string* release_node();
  void set_allocated_node(::std::string* node);

  // repeated .mprs.Resource resources = 2;
  int resources_size() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 2;
  const ::mprs::Resource& resources(int index) const;
  ::mprs::Resource* mutable_resources(int index);
  ::mprs::Resource* add_resources();
  ::google::protobuf::RepeatedPtrField< ::mprs::Resource >*
      mutable_resources();
  const ::google::protobuf::RepeatedPtrField< ::mprs::Resource >&
      resources() const;

  // @@protoc_insertion_point(class_scope:mprs.NodeResources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr node_;
  ::google::protobuf::RepeatedPtrField< ::mprs::Resource > resources_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NodeResources* default_instance_;
};
// -------------------------------------------------------------------

class MprsInstanceID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.MprsInstanceID) */ {
 public:
  MprsInstanceID();
  virtual ~MprsInstanceID();

  MprsInstanceID(const MprsInstanceID& from);

  inline MprsInstanceID& operator=(const MprsInstanceID& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MprsInstanceID& default_instance();

  void Swap(MprsInstanceID* other);

  // implements Message ----------------------------------------------

  inline MprsInstanceID* New() const { return New(NULL); }

  MprsInstanceID* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MprsInstanceID& from);
  void MergeFrom(const MprsInstanceID& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MprsInstanceID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 start_time = 1;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  ::google::protobuf::int64 start_time() const;
  void set_start_time(::google::protobuf::int64 value);

  // optional int64 rand = 2;
  void clear_rand();
  static const int kRandFieldNumber = 2;
  ::google::protobuf::int64 rand() const;
  void set_rand(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mprs.MprsInstanceID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 start_time_;
  ::google::protobuf::int64 rand_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static MprsInstanceID* default_instance_;
};
// -------------------------------------------------------------------

class RunningTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.RunningTask) */ {
 public:
  RunningTask();
  virtual ~RunningTask();

  RunningTask(const RunningTask& from);

  inline RunningTask& operator=(const RunningTask& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunningTask& default_instance();

  void Swap(RunningTask* other);

  // implements Message ----------------------------------------------

  inline RunningTask* New() const { return New(NULL); }

  RunningTask* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunningTask& from);
  void MergeFrom(const RunningTask& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RunningTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string job = 1;
  void clear_job();
  static const int kJobFieldNumber = 1;
  const ::std::string& job() const;
  void set_job(const ::std::string& value);
  void set_job(const char* value);
  void set_job(const char* value, size_t size);
  ::std::string* mutable_job();
  ::std::string* release_job();
  void set_allocated_job(::std::string* job);

  // optional string node = 2;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::std::string& node() const;
  void set_node(const ::std::string& value);
  void set_node(const char* value);
  void set_node(const char* value, size_t size);
  ::std::string* mutable_node();
  ::std::string* release_node();
  void set_allocated_node(::std::string* node);

  // repeated .mprs.NodeResources node_resources = 3;
  int node_resources_size() const;
  void clear_node_resources();
  static const int kNodeResourcesFieldNumber = 3;
  const ::mprs::NodeResources& node_resources(int index) const;
  ::mprs::NodeResources* mutable_node_resources(int index);
  ::mprs::NodeResources* add_node_resources();
  ::google::protobuf::RepeatedPtrField< ::mprs::NodeResources >*
      mutable_node_resources();
  const ::google::protobuf::RepeatedPtrField< ::mprs::NodeResources >&
      node_resources() const;

  // optional string worker_shard = 4;
  void clear_worker_shard();
  static const int kWorkerShardFieldNumber = 4;
  const ::std::string& worker_shard() const;
  void set_worker_shard(const ::std::string& value);
  void set_worker_shard(const char* value);
  void set_worker_shard(const char* value, size_t size);
  ::std::string* mutable_worker_shard();
  ::std::string* release_worker_shard();
  void set_allocated_worker_shard(::std::string* worker_shard);

  // optional .mprs.MprsInstanceID invocation_id = 5;
  bool has_invocation_id() const;
  void clear_invocation_id();
  static const int kInvocationIdFieldNumber = 5;
  const ::mprs::MprsInstanceID& invocation_id() const;
  ::mprs::MprsInstanceID* mutable_invocation_id();
  ::mprs::MprsInstanceID* release_invocation_id();
  void set_allocated_invocation_id(::mprs::MprsInstanceID* invocation_id);

  // optional .mprs.BackoffDuration next_backoff_duration = 6;
  bool has_next_backoff_duration() const;
  void clear_next_backoff_duration();
  static const int kNextBackoffDurationFieldNumber = 6;
  const ::mprs::BackoffDuration& next_backoff_duration() const;
  ::mprs::BackoffDuration* mutable_next_backoff_duration();
  ::mprs::BackoffDuration* release_next_backoff_duration();
  void set_allocated_next_backoff_duration(::mprs::BackoffDuration* next_backoff_duration);

  // @@protoc_insertion_point(class_scope:mprs.RunningTask)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr job_;
  ::google::protobuf::internal::ArenaStringPtr node_;
  ::google::protobuf::RepeatedPtrField< ::mprs::NodeResources > node_resources_;
  ::google::protobuf::internal::ArenaStringPtr worker_shard_;
  ::mprs::MprsInstanceID* invocation_id_;
  ::mprs::BackoffDuration* next_backoff_duration_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RunningTask* default_instance_;
};
// -------------------------------------------------------------------

class MachinePortLock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.MachinePortLock) */ {
 public:
  MachinePortLock();
  virtual ~MachinePortLock();

  MachinePortLock(const MachinePortLock& from);

  inline MachinePortLock& operator=(const MachinePortLock& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MachinePortLock& default_instance();

  void Swap(MachinePortLock* other);

  // implements Message ----------------------------------------------

  inline MachinePortLock* New() const { return New(NULL); }

  MachinePortLock* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MachinePortLock& from);
  void MergeFrom(const MachinePortLock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MachinePortLock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  const ::std::string& hostname() const;
  void set_hostname(const ::std::string& value);
  void set_hostname(const char* value);
  void set_hostname(const char* value, size_t size);
  ::std::string* mutable_hostname();
  ::std::string* release_hostname();
  void set_allocated_hostname(::std::string* hostname);

  // optional int32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mprs.MachinePortLock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr hostname_;
  ::google::protobuf::int32 port_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static MachinePortLock* default_instance_;
};
// -------------------------------------------------------------------

class ServiceAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.ServiceAddress) */ {
 public:
  ServiceAddress();
  virtual ~ServiceAddress();

  ServiceAddress(const ServiceAddress& from);

  inline ServiceAddress& operator=(const ServiceAddress& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceAddress& default_instance();

  void Swap(ServiceAddress* other);

  // implements Message ----------------------------------------------

  inline ServiceAddress* New() const { return New(NULL); }

  ServiceAddress* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceAddress& from);
  void MergeFrom(const ServiceAddress& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServiceAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip_or_host = 1;
  void clear_ip_or_host();
  static const int kIpOrHostFieldNumber = 1;
  const ::std::string& ip_or_host() const;
  void set_ip_or_host(const ::std::string& value);
  void set_ip_or_host(const char* value);
  void set_ip_or_host(const char* value, size_t size);
  ::std::string* mutable_ip_or_host();
  ::std::string* release_ip_or_host();
  void set_allocated_ip_or_host(::std::string* ip_or_host);

  // optional int32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mprs.ServiceAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr ip_or_host_;
  ::google::protobuf::int32 port_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ServiceAddress* default_instance_;
};
// -------------------------------------------------------------------

class MprsWorker : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.MprsWorker) */ {
 public:
  MprsWorker();
  virtual ~MprsWorker();

  MprsWorker(const MprsWorker& from);

  inline MprsWorker& operator=(const MprsWorker& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MprsWorker& default_instance();

  void Swap(MprsWorker* other);

  // implements Message ----------------------------------------------

  inline MprsWorker* New() const { return New(NULL); }

  MprsWorker* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MprsWorker& from);
  void MergeFrom(const MprsWorker& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MprsWorker* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string shard = 1;
  void clear_shard();
  static const int kShardFieldNumber = 1;
  const ::std::string& shard() const;
  void set_shard(const ::std::string& value);
  void set_shard(const char* value);
  void set_shard(const char* value, size_t size);
  ::std::string* mutable_shard();
  ::std::string* release_shard();
  void set_allocated_shard(::std::string* shard);

  // optional .mprs.MachinePortLock machine_lock = 2;
  bool has_machine_lock() const;
  void clear_machine_lock();
  static const int kMachineLockFieldNumber = 2;
  const ::mprs::MachinePortLock& machine_lock() const;
  ::mprs::MachinePortLock* mutable_machine_lock();
  ::mprs::MachinePortLock* release_machine_lock();
  void set_allocated_machine_lock(::mprs::MachinePortLock* machine_lock);

  // optional .mprs.ServiceAddress addr = 3;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 3;
  const ::mprs::ServiceAddress& addr() const;
  ::mprs::ServiceAddress* mutable_addr();
  ::mprs::ServiceAddress* release_addr();
  void set_allocated_addr(::mprs::ServiceAddress* addr);

  // optional .mprs.MprsInstanceID id = 4;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 4;
  const ::mprs::MprsInstanceID& id() const;
  ::mprs::MprsInstanceID* mutable_id();
  ::mprs::MprsInstanceID* release_id();
  void set_allocated_id(::mprs::MprsInstanceID* id);

  // optional int32 heartbeat_period_second = 5;
  void clear_heartbeat_period_second();
  static const int kHeartbeatPeriodSecondFieldNumber = 5;
  ::google::protobuf::int32 heartbeat_period_second() const;
  void set_heartbeat_period_second(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mprs.MprsWorker)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr shard_;
  ::mprs::MachinePortLock* machine_lock_;
  ::mprs::ServiceAddress* addr_;
  ::mprs::MprsInstanceID* id_;
  ::google::protobuf::int32 heartbeat_period_second_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static MprsWorker* default_instance_;
};
// -------------------------------------------------------------------

class SchedulerHeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mprs.SchedulerHeartbeatResponse) */ {
 public:
  SchedulerHeartbeatResponse();
  virtual ~SchedulerHeartbeatResponse();

  SchedulerHeartbeatResponse(const SchedulerHeartbeatResponse& from);

  inline SchedulerHeartbeatResponse& operator=(const SchedulerHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SchedulerHeartbeatResponse& default_instance();

  void Swap(SchedulerHeartbeatResponse* other);

  // implements Message ----------------------------------------------

  inline SchedulerHeartbeatResponse* New() const { return New(NULL); }

  SchedulerHeartbeatResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SchedulerHeartbeatResponse& from);
  void MergeFrom(const SchedulerHeartbeatResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SchedulerHeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mprs.MprsInstanceID id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::mprs::MprsInstanceID& id() const;
  ::mprs::MprsInstanceID* mutable_id();
  ::mprs::MprsInstanceID* release_id();
  void set_allocated_id(::mprs::MprsInstanceID* id);

  // optional int32 max_health_check_gap = 2;
  void clear_max_health_check_gap();
  static const int kMaxHealthCheckGapFieldNumber = 2;
  ::google::protobuf::int32 max_health_check_gap() const;
  void set_max_health_check_gap(::google::protobuf::int32 value);

  // optional int32 heartbeat_grace_period = 3;
  void clear_heartbeat_grace_period();
  static const int kHeartbeatGracePeriodFieldNumber = 3;
  ::google::protobuf::int32 heartbeat_grace_period() const;
  void set_heartbeat_grace_period(::google::protobuf::int32 value);

  // optional int32 lose_unhealthy_worker_after = 4;
  void clear_lose_unhealthy_worker_after();
  static const int kLoseUnhealthyWorkerAfterFieldNumber = 4;
  ::google::protobuf::int32 lose_unhealthy_worker_after() const;
  void set_lose_unhealthy_worker_after(::google::protobuf::int32 value);

  // optional int32 worker_check_interval = 5;
  void clear_worker_check_interval();
  static const int kWorkerCheckIntervalFieldNumber = 5;
  ::google::protobuf::int32 worker_check_interval() const;
  void set_worker_check_interval(::google::protobuf::int32 value);

  // optional int32 worker_state = 6;
  void clear_worker_state();
  static const int kWorkerStateFieldNumber = 6;
  ::google::protobuf::int32 worker_state() const;
  void set_worker_state(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mprs.SchedulerHeartbeatResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::mprs::MprsInstanceID* id_;
  ::google::protobuf::int32 max_health_check_gap_;
  ::google::protobuf::int32 heartbeat_grace_period_;
  ::google::protobuf::int32 lose_unhealthy_worker_after_;
  ::google::protobuf::int32 worker_check_interval_;
  ::google::protobuf::int32 worker_state_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static SchedulerHeartbeatResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// BackoffDuration

// optional bool no_more_backoffs = 1;
inline void BackoffDuration::clear_no_more_backoffs() {
  no_more_backoffs_ = false;
}
inline bool BackoffDuration::no_more_backoffs() const {
  // @@protoc_insertion_point(field_get:mprs.BackoffDuration.no_more_backoffs)
  return no_more_backoffs_;
}
inline void BackoffDuration::set_no_more_backoffs(bool value) {
  
  no_more_backoffs_ = value;
  // @@protoc_insertion_point(field_set:mprs.BackoffDuration.no_more_backoffs)
}

// optional int32 seconds = 2;
inline void BackoffDuration::clear_seconds() {
  seconds_ = 0;
}
inline ::google::protobuf::int32 BackoffDuration::seconds() const {
  // @@protoc_insertion_point(field_get:mprs.BackoffDuration.seconds)
  return seconds_;
}
inline void BackoffDuration::set_seconds(::google::protobuf::int32 value) {
  
  seconds_ = value;
  // @@protoc_insertion_point(field_set:mprs.BackoffDuration.seconds)
}

// -------------------------------------------------------------------

// LogLine

// optional string job_id = 1;
inline void LogLine::clear_job_id() {
  job_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogLine::job_id() const {
  // @@protoc_insertion_point(field_get:mprs.LogLine.job_id)
  return job_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogLine::set_job_id(const ::std::string& value) {
  
  job_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.LogLine.job_id)
}
inline void LogLine::set_job_id(const char* value) {
  
  job_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.LogLine.job_id)
}
inline void LogLine::set_job_id(const char* value, size_t size) {
  
  job_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.LogLine.job_id)
}
inline ::std::string* LogLine::mutable_job_id() {
  
  // @@protoc_insertion_point(field_mutable:mprs.LogLine.job_id)
  return job_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogLine::release_job_id() {
  // @@protoc_insertion_point(field_release:mprs.LogLine.job_id)
  
  return job_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogLine::set_allocated_job_id(::std::string* job_id) {
  if (job_id != NULL) {
    
  } else {
    
  }
  job_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), job_id);
  // @@protoc_insertion_point(field_set_allocated:mprs.LogLine.job_id)
}

// optional string node_id = 2;
inline void LogLine::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogLine::node_id() const {
  // @@protoc_insertion_point(field_get:mprs.LogLine.node_id)
  return node_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogLine::set_node_id(const ::std::string& value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.LogLine.node_id)
}
inline void LogLine::set_node_id(const char* value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.LogLine.node_id)
}
inline void LogLine::set_node_id(const char* value, size_t size) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.LogLine.node_id)
}
inline ::std::string* LogLine::mutable_node_id() {
  
  // @@protoc_insertion_point(field_mutable:mprs.LogLine.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogLine::release_node_id() {
  // @@protoc_insertion_point(field_release:mprs.LogLine.node_id)
  
  return node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogLine::set_allocated_node_id(::std::string* node_id) {
  if (node_id != NULL) {
    
  } else {
    
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:mprs.LogLine.node_id)
}

// optional int32 time = 3;
inline void LogLine::clear_time() {
  time_ = 0;
}
inline ::google::protobuf::int32 LogLine::time() const {
  // @@protoc_insertion_point(field_get:mprs.LogLine.time)
  return time_;
}
inline void LogLine::set_time(::google::protobuf::int32 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:mprs.LogLine.time)
}

// optional string line = 4;
inline void LogLine::clear_line() {
  line_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogLine::line() const {
  // @@protoc_insertion_point(field_get:mprs.LogLine.line)
  return line_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogLine::set_line(const ::std::string& value) {
  
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.LogLine.line)
}
inline void LogLine::set_line(const char* value) {
  
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.LogLine.line)
}
inline void LogLine::set_line(const char* value, size_t size) {
  
  line_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.LogLine.line)
}
inline ::std::string* LogLine::mutable_line() {
  
  // @@protoc_insertion_point(field_mutable:mprs.LogLine.line)
  return line_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogLine::release_line() {
  // @@protoc_insertion_point(field_release:mprs.LogLine.line)
  
  return line_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogLine::set_allocated_line(::std::string* line) {
  if (line != NULL) {
    
  } else {
    
  }
  line_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), line);
  // @@protoc_insertion_point(field_set_allocated:mprs.LogLine.line)
}

// optional int64 line_id = 5;
inline void LogLine::clear_line_id() {
  line_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LogLine::line_id() const {
  // @@protoc_insertion_point(field_get:mprs.LogLine.line_id)
  return line_id_;
}
inline void LogLine::set_line_id(::google::protobuf::int64 value) {
  
  line_id_ = value;
  // @@protoc_insertion_point(field_set:mprs.LogLine.line_id)
}

// -------------------------------------------------------------------

// LogLines

// repeated .mprs.LogLine lines = 1;
inline int LogLines::lines_size() const {
  return lines_.size();
}
inline void LogLines::clear_lines() {
  lines_.Clear();
}
inline const ::mprs::LogLine& LogLines::lines(int index) const {
  // @@protoc_insertion_point(field_get:mprs.LogLines.lines)
  return lines_.Get(index);
}
inline ::mprs::LogLine* LogLines::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:mprs.LogLines.lines)
  return lines_.Mutable(index);
}
inline ::mprs::LogLine* LogLines::add_lines() {
  // @@protoc_insertion_point(field_add:mprs.LogLines.lines)
  return lines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mprs::LogLine >*
LogLines::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:mprs.LogLines.lines)
  return &lines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mprs::LogLine >&
LogLines::lines() const {
  // @@protoc_insertion_point(field_list:mprs.LogLines.lines)
  return lines_;
}

// optional int64 next_line_id = 2;
inline void LogLines::clear_next_line_id() {
  next_line_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LogLines::next_line_id() const {
  // @@protoc_insertion_point(field_get:mprs.LogLines.next_line_id)
  return next_line_id_;
}
inline void LogLines::set_next_line_id(::google::protobuf::int64 value) {
  
  next_line_id_ = value;
  // @@protoc_insertion_point(field_set:mprs.LogLines.next_line_id)
}

// -------------------------------------------------------------------

// Resource

// optional string name = 1;
inline void Resource::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Resource::name() const {
  // @@protoc_insertion_point(field_get:mprs.Resource.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resource::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.Resource.name)
}
inline void Resource::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.Resource.name)
}
inline void Resource::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.Resource.name)
}
inline ::std::string* Resource::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:mprs.Resource.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Resource::release_name() {
  // @@protoc_insertion_point(field_release:mprs.Resource.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Resource::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mprs.Resource.name)
}

// optional int32 amount = 2;
inline void Resource::clear_amount() {
  amount_ = 0;
}
inline ::google::protobuf::int32 Resource::amount() const {
  // @@protoc_insertion_point(field_get:mprs.Resource.amount)
  return amount_;
}
inline void Resource::set_amount(::google::protobuf::int32 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:mprs.Resource.amount)
}

// -------------------------------------------------------------------

// NodeResources

// optional string node = 1;
inline void NodeResources::clear_node() {
  node_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeResources::node() const {
  // @@protoc_insertion_point(field_get:mprs.NodeResources.node)
  return node_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeResources::set_node(const ::std::string& value) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.NodeResources.node)
}
inline void NodeResources::set_node(const char* value) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.NodeResources.node)
}
inline void NodeResources::set_node(const char* value, size_t size) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.NodeResources.node)
}
inline ::std::string* NodeResources::mutable_node() {
  
  // @@protoc_insertion_point(field_mutable:mprs.NodeResources.node)
  return node_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeResources::release_node() {
  // @@protoc_insertion_point(field_release:mprs.NodeResources.node)
  
  return node_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeResources::set_allocated_node(::std::string* node) {
  if (node != NULL) {
    
  } else {
    
  }
  node_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node);
  // @@protoc_insertion_point(field_set_allocated:mprs.NodeResources.node)
}

// repeated .mprs.Resource resources = 2;
inline int NodeResources::resources_size() const {
  return resources_.size();
}
inline void NodeResources::clear_resources() {
  resources_.Clear();
}
inline const ::mprs::Resource& NodeResources::resources(int index) const {
  // @@protoc_insertion_point(field_get:mprs.NodeResources.resources)
  return resources_.Get(index);
}
inline ::mprs::Resource* NodeResources::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mprs.NodeResources.resources)
  return resources_.Mutable(index);
}
inline ::mprs::Resource* NodeResources::add_resources() {
  // @@protoc_insertion_point(field_add:mprs.NodeResources.resources)
  return resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mprs::Resource >*
NodeResources::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mprs.NodeResources.resources)
  return &resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mprs::Resource >&
NodeResources::resources() const {
  // @@protoc_insertion_point(field_list:mprs.NodeResources.resources)
  return resources_;
}

// -------------------------------------------------------------------

// MprsInstanceID

// optional int64 start_time = 1;
inline void MprsInstanceID::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MprsInstanceID::start_time() const {
  // @@protoc_insertion_point(field_get:mprs.MprsInstanceID.start_time)
  return start_time_;
}
inline void MprsInstanceID::set_start_time(::google::protobuf::int64 value) {
  
  start_time_ = value;
  // @@protoc_insertion_point(field_set:mprs.MprsInstanceID.start_time)
}

// optional int64 rand = 2;
inline void MprsInstanceID::clear_rand() {
  rand_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MprsInstanceID::rand() const {
  // @@protoc_insertion_point(field_get:mprs.MprsInstanceID.rand)
  return rand_;
}
inline void MprsInstanceID::set_rand(::google::protobuf::int64 value) {
  
  rand_ = value;
  // @@protoc_insertion_point(field_set:mprs.MprsInstanceID.rand)
}

// -------------------------------------------------------------------

// RunningTask

// optional string job = 1;
inline void RunningTask::clear_job() {
  job_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunningTask::job() const {
  // @@protoc_insertion_point(field_get:mprs.RunningTask.job)
  return job_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunningTask::set_job(const ::std::string& value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.RunningTask.job)
}
inline void RunningTask::set_job(const char* value) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.RunningTask.job)
}
inline void RunningTask::set_job(const char* value, size_t size) {
  
  job_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.RunningTask.job)
}
inline ::std::string* RunningTask::mutable_job() {
  
  // @@protoc_insertion_point(field_mutable:mprs.RunningTask.job)
  return job_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunningTask::release_job() {
  // @@protoc_insertion_point(field_release:mprs.RunningTask.job)
  
  return job_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunningTask::set_allocated_job(::std::string* job) {
  if (job != NULL) {
    
  } else {
    
  }
  job_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), job);
  // @@protoc_insertion_point(field_set_allocated:mprs.RunningTask.job)
}

// optional string node = 2;
inline void RunningTask::clear_node() {
  node_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunningTask::node() const {
  // @@protoc_insertion_point(field_get:mprs.RunningTask.node)
  return node_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunningTask::set_node(const ::std::string& value) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.RunningTask.node)
}
inline void RunningTask::set_node(const char* value) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.RunningTask.node)
}
inline void RunningTask::set_node(const char* value, size_t size) {
  
  node_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.RunningTask.node)
}
inline ::std::string* RunningTask::mutable_node() {
  
  // @@protoc_insertion_point(field_mutable:mprs.RunningTask.node)
  return node_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunningTask::release_node() {
  // @@protoc_insertion_point(field_release:mprs.RunningTask.node)
  
  return node_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunningTask::set_allocated_node(::std::string* node) {
  if (node != NULL) {
    
  } else {
    
  }
  node_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node);
  // @@protoc_insertion_point(field_set_allocated:mprs.RunningTask.node)
}

// repeated .mprs.NodeResources node_resources = 3;
inline int RunningTask::node_resources_size() const {
  return node_resources_.size();
}
inline void RunningTask::clear_node_resources() {
  node_resources_.Clear();
}
inline const ::mprs::NodeResources& RunningTask::node_resources(int index) const {
  // @@protoc_insertion_point(field_get:mprs.RunningTask.node_resources)
  return node_resources_.Get(index);
}
inline ::mprs::NodeResources* RunningTask::mutable_node_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mprs.RunningTask.node_resources)
  return node_resources_.Mutable(index);
}
inline ::mprs::NodeResources* RunningTask::add_node_resources() {
  // @@protoc_insertion_point(field_add:mprs.RunningTask.node_resources)
  return node_resources_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mprs::NodeResources >*
RunningTask::mutable_node_resources() {
  // @@protoc_insertion_point(field_mutable_list:mprs.RunningTask.node_resources)
  return &node_resources_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mprs::NodeResources >&
RunningTask::node_resources() const {
  // @@protoc_insertion_point(field_list:mprs.RunningTask.node_resources)
  return node_resources_;
}

// optional string worker_shard = 4;
inline void RunningTask::clear_worker_shard() {
  worker_shard_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RunningTask::worker_shard() const {
  // @@protoc_insertion_point(field_get:mprs.RunningTask.worker_shard)
  return worker_shard_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunningTask::set_worker_shard(const ::std::string& value) {
  
  worker_shard_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.RunningTask.worker_shard)
}
inline void RunningTask::set_worker_shard(const char* value) {
  
  worker_shard_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.RunningTask.worker_shard)
}
inline void RunningTask::set_worker_shard(const char* value, size_t size) {
  
  worker_shard_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.RunningTask.worker_shard)
}
inline ::std::string* RunningTask::mutable_worker_shard() {
  
  // @@protoc_insertion_point(field_mutable:mprs.RunningTask.worker_shard)
  return worker_shard_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunningTask::release_worker_shard() {
  // @@protoc_insertion_point(field_release:mprs.RunningTask.worker_shard)
  
  return worker_shard_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunningTask::set_allocated_worker_shard(::std::string* worker_shard) {
  if (worker_shard != NULL) {
    
  } else {
    
  }
  worker_shard_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worker_shard);
  // @@protoc_insertion_point(field_set_allocated:mprs.RunningTask.worker_shard)
}

// optional .mprs.MprsInstanceID invocation_id = 5;
inline bool RunningTask::has_invocation_id() const {
  return !_is_default_instance_ && invocation_id_ != NULL;
}
inline void RunningTask::clear_invocation_id() {
  if (GetArenaNoVirtual() == NULL && invocation_id_ != NULL) delete invocation_id_;
  invocation_id_ = NULL;
}
inline const ::mprs::MprsInstanceID& RunningTask::invocation_id() const {
  // @@protoc_insertion_point(field_get:mprs.RunningTask.invocation_id)
  return invocation_id_ != NULL ? *invocation_id_ : *default_instance_->invocation_id_;
}
inline ::mprs::MprsInstanceID* RunningTask::mutable_invocation_id() {
  
  if (invocation_id_ == NULL) {
    invocation_id_ = new ::mprs::MprsInstanceID;
  }
  // @@protoc_insertion_point(field_mutable:mprs.RunningTask.invocation_id)
  return invocation_id_;
}
inline ::mprs::MprsInstanceID* RunningTask::release_invocation_id() {
  // @@protoc_insertion_point(field_release:mprs.RunningTask.invocation_id)
  
  ::mprs::MprsInstanceID* temp = invocation_id_;
  invocation_id_ = NULL;
  return temp;
}
inline void RunningTask::set_allocated_invocation_id(::mprs::MprsInstanceID* invocation_id) {
  delete invocation_id_;
  invocation_id_ = invocation_id;
  if (invocation_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mprs.RunningTask.invocation_id)
}

// optional .mprs.BackoffDuration next_backoff_duration = 6;
inline bool RunningTask::has_next_backoff_duration() const {
  return !_is_default_instance_ && next_backoff_duration_ != NULL;
}
inline void RunningTask::clear_next_backoff_duration() {
  if (GetArenaNoVirtual() == NULL && next_backoff_duration_ != NULL) delete next_backoff_duration_;
  next_backoff_duration_ = NULL;
}
inline const ::mprs::BackoffDuration& RunningTask::next_backoff_duration() const {
  // @@protoc_insertion_point(field_get:mprs.RunningTask.next_backoff_duration)
  return next_backoff_duration_ != NULL ? *next_backoff_duration_ : *default_instance_->next_backoff_duration_;
}
inline ::mprs::BackoffDuration* RunningTask::mutable_next_backoff_duration() {
  
  if (next_backoff_duration_ == NULL) {
    next_backoff_duration_ = new ::mprs::BackoffDuration;
  }
  // @@protoc_insertion_point(field_mutable:mprs.RunningTask.next_backoff_duration)
  return next_backoff_duration_;
}
inline ::mprs::BackoffDuration* RunningTask::release_next_backoff_duration() {
  // @@protoc_insertion_point(field_release:mprs.RunningTask.next_backoff_duration)
  
  ::mprs::BackoffDuration* temp = next_backoff_duration_;
  next_backoff_duration_ = NULL;
  return temp;
}
inline void RunningTask::set_allocated_next_backoff_duration(::mprs::BackoffDuration* next_backoff_duration) {
  delete next_backoff_duration_;
  next_backoff_duration_ = next_backoff_duration;
  if (next_backoff_duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mprs.RunningTask.next_backoff_duration)
}

// -------------------------------------------------------------------

// MachinePortLock

// optional string hostname = 1;
inline void MachinePortLock::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MachinePortLock::hostname() const {
  // @@protoc_insertion_point(field_get:mprs.MachinePortLock.hostname)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MachinePortLock::set_hostname(const ::std::string& value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.MachinePortLock.hostname)
}
inline void MachinePortLock::set_hostname(const char* value) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.MachinePortLock.hostname)
}
inline void MachinePortLock::set_hostname(const char* value, size_t size) {
  
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.MachinePortLock.hostname)
}
inline ::std::string* MachinePortLock::mutable_hostname() {
  
  // @@protoc_insertion_point(field_mutable:mprs.MachinePortLock.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MachinePortLock::release_hostname() {
  // @@protoc_insertion_point(field_release:mprs.MachinePortLock.hostname)
  
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MachinePortLock::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    
  } else {
    
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:mprs.MachinePortLock.hostname)
}

// optional int32 port = 2;
inline void MachinePortLock::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 MachinePortLock::port() const {
  // @@protoc_insertion_point(field_get:mprs.MachinePortLock.port)
  return port_;
}
inline void MachinePortLock::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:mprs.MachinePortLock.port)
}

// -------------------------------------------------------------------

// ServiceAddress

// optional string ip_or_host = 1;
inline void ServiceAddress::clear_ip_or_host() {
  ip_or_host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServiceAddress::ip_or_host() const {
  // @@protoc_insertion_point(field_get:mprs.ServiceAddress.ip_or_host)
  return ip_or_host_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceAddress::set_ip_or_host(const ::std::string& value) {
  
  ip_or_host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.ServiceAddress.ip_or_host)
}
inline void ServiceAddress::set_ip_or_host(const char* value) {
  
  ip_or_host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.ServiceAddress.ip_or_host)
}
inline void ServiceAddress::set_ip_or_host(const char* value, size_t size) {
  
  ip_or_host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.ServiceAddress.ip_or_host)
}
inline ::std::string* ServiceAddress::mutable_ip_or_host() {
  
  // @@protoc_insertion_point(field_mutable:mprs.ServiceAddress.ip_or_host)
  return ip_or_host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServiceAddress::release_ip_or_host() {
  // @@protoc_insertion_point(field_release:mprs.ServiceAddress.ip_or_host)
  
  return ip_or_host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServiceAddress::set_allocated_ip_or_host(::std::string* ip_or_host) {
  if (ip_or_host != NULL) {
    
  } else {
    
  }
  ip_or_host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_or_host);
  // @@protoc_insertion_point(field_set_allocated:mprs.ServiceAddress.ip_or_host)
}

// optional int32 port = 2;
inline void ServiceAddress::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 ServiceAddress::port() const {
  // @@protoc_insertion_point(field_get:mprs.ServiceAddress.port)
  return port_;
}
inline void ServiceAddress::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:mprs.ServiceAddress.port)
}

// -------------------------------------------------------------------

// MprsWorker

// optional string shard = 1;
inline void MprsWorker::clear_shard() {
  shard_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MprsWorker::shard() const {
  // @@protoc_insertion_point(field_get:mprs.MprsWorker.shard)
  return shard_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MprsWorker::set_shard(const ::std::string& value) {
  
  shard_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mprs.MprsWorker.shard)
}
inline void MprsWorker::set_shard(const char* value) {
  
  shard_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mprs.MprsWorker.shard)
}
inline void MprsWorker::set_shard(const char* value, size_t size) {
  
  shard_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mprs.MprsWorker.shard)
}
inline ::std::string* MprsWorker::mutable_shard() {
  
  // @@protoc_insertion_point(field_mutable:mprs.MprsWorker.shard)
  return shard_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MprsWorker::release_shard() {
  // @@protoc_insertion_point(field_release:mprs.MprsWorker.shard)
  
  return shard_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MprsWorker::set_allocated_shard(::std::string* shard) {
  if (shard != NULL) {
    
  } else {
    
  }
  shard_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shard);
  // @@protoc_insertion_point(field_set_allocated:mprs.MprsWorker.shard)
}

// optional .mprs.MachinePortLock machine_lock = 2;
inline bool MprsWorker::has_machine_lock() const {
  return !_is_default_instance_ && machine_lock_ != NULL;
}
inline void MprsWorker::clear_machine_lock() {
  if (GetArenaNoVirtual() == NULL && machine_lock_ != NULL) delete machine_lock_;
  machine_lock_ = NULL;
}
inline const ::mprs::MachinePortLock& MprsWorker::machine_lock() const {
  // @@protoc_insertion_point(field_get:mprs.MprsWorker.machine_lock)
  return machine_lock_ != NULL ? *machine_lock_ : *default_instance_->machine_lock_;
}
inline ::mprs::MachinePortLock* MprsWorker::mutable_machine_lock() {
  
  if (machine_lock_ == NULL) {
    machine_lock_ = new ::mprs::MachinePortLock;
  }
  // @@protoc_insertion_point(field_mutable:mprs.MprsWorker.machine_lock)
  return machine_lock_;
}
inline ::mprs::MachinePortLock* MprsWorker::release_machine_lock() {
  // @@protoc_insertion_point(field_release:mprs.MprsWorker.machine_lock)
  
  ::mprs::MachinePortLock* temp = machine_lock_;
  machine_lock_ = NULL;
  return temp;
}
inline void MprsWorker::set_allocated_machine_lock(::mprs::MachinePortLock* machine_lock) {
  delete machine_lock_;
  machine_lock_ = machine_lock;
  if (machine_lock) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mprs.MprsWorker.machine_lock)
}

// optional .mprs.ServiceAddress addr = 3;
inline bool MprsWorker::has_addr() const {
  return !_is_default_instance_ && addr_ != NULL;
}
inline void MprsWorker::clear_addr() {
  if (GetArenaNoVirtual() == NULL && addr_ != NULL) delete addr_;
  addr_ = NULL;
}
inline const ::mprs::ServiceAddress& MprsWorker::addr() const {
  // @@protoc_insertion_point(field_get:mprs.MprsWorker.addr)
  return addr_ != NULL ? *addr_ : *default_instance_->addr_;
}
inline ::mprs::ServiceAddress* MprsWorker::mutable_addr() {
  
  if (addr_ == NULL) {
    addr_ = new ::mprs::ServiceAddress;
  }
  // @@protoc_insertion_point(field_mutable:mprs.MprsWorker.addr)
  return addr_;
}
inline ::mprs::ServiceAddress* MprsWorker::release_addr() {
  // @@protoc_insertion_point(field_release:mprs.MprsWorker.addr)
  
  ::mprs::ServiceAddress* temp = addr_;
  addr_ = NULL;
  return temp;
}
inline void MprsWorker::set_allocated_addr(::mprs::ServiceAddress* addr) {
  delete addr_;
  addr_ = addr;
  if (addr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mprs.MprsWorker.addr)
}

// optional .mprs.MprsInstanceID id = 4;
inline bool MprsWorker::has_id() const {
  return !_is_default_instance_ && id_ != NULL;
}
inline void MprsWorker::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) delete id_;
  id_ = NULL;
}
inline const ::mprs::MprsInstanceID& MprsWorker::id() const {
  // @@protoc_insertion_point(field_get:mprs.MprsWorker.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mprs::MprsInstanceID* MprsWorker::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::mprs::MprsInstanceID;
  }
  // @@protoc_insertion_point(field_mutable:mprs.MprsWorker.id)
  return id_;
}
inline ::mprs::MprsInstanceID* MprsWorker::release_id() {
  // @@protoc_insertion_point(field_release:mprs.MprsWorker.id)
  
  ::mprs::MprsInstanceID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void MprsWorker::set_allocated_id(::mprs::MprsInstanceID* id) {
  delete id_;
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mprs.MprsWorker.id)
}

// optional int32 heartbeat_period_second = 5;
inline void MprsWorker::clear_heartbeat_period_second() {
  heartbeat_period_second_ = 0;
}
inline ::google::protobuf::int32 MprsWorker::heartbeat_period_second() const {
  // @@protoc_insertion_point(field_get:mprs.MprsWorker.heartbeat_period_second)
  return heartbeat_period_second_;
}
inline void MprsWorker::set_heartbeat_period_second(::google::protobuf::int32 value) {
  
  heartbeat_period_second_ = value;
  // @@protoc_insertion_point(field_set:mprs.MprsWorker.heartbeat_period_second)
}

// -------------------------------------------------------------------

// SchedulerHeartbeatResponse

// optional .mprs.MprsInstanceID id = 1;
inline bool SchedulerHeartbeatResponse::has_id() const {
  return !_is_default_instance_ && id_ != NULL;
}
inline void SchedulerHeartbeatResponse::clear_id() {
  if (GetArenaNoVirtual() == NULL && id_ != NULL) delete id_;
  id_ = NULL;
}
inline const ::mprs::MprsInstanceID& SchedulerHeartbeatResponse::id() const {
  // @@protoc_insertion_point(field_get:mprs.SchedulerHeartbeatResponse.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::mprs::MprsInstanceID* SchedulerHeartbeatResponse::mutable_id() {
  
  if (id_ == NULL) {
    id_ = new ::mprs::MprsInstanceID;
  }
  // @@protoc_insertion_point(field_mutable:mprs.SchedulerHeartbeatResponse.id)
  return id_;
}
inline ::mprs::MprsInstanceID* SchedulerHeartbeatResponse::release_id() {
  // @@protoc_insertion_point(field_release:mprs.SchedulerHeartbeatResponse.id)
  
  ::mprs::MprsInstanceID* temp = id_;
  id_ = NULL;
  return temp;
}
inline void SchedulerHeartbeatResponse::set_allocated_id(::mprs::MprsInstanceID* id) {
  delete id_;
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:mprs.SchedulerHeartbeatResponse.id)
}

// optional int32 max_health_check_gap = 2;
inline void SchedulerHeartbeatResponse::clear_max_health_check_gap() {
  max_health_check_gap_ = 0;
}
inline ::google::protobuf::int32 SchedulerHeartbeatResponse::max_health_check_gap() const {
  // @@protoc_insertion_point(field_get:mprs.SchedulerHeartbeatResponse.max_health_check_gap)
  return max_health_check_gap_;
}
inline void SchedulerHeartbeatResponse::set_max_health_check_gap(::google::protobuf::int32 value) {
  
  max_health_check_gap_ = value;
  // @@protoc_insertion_point(field_set:mprs.SchedulerHeartbeatResponse.max_health_check_gap)
}

// optional int32 heartbeat_grace_period = 3;
inline void SchedulerHeartbeatResponse::clear_heartbeat_grace_period() {
  heartbeat_grace_period_ = 0;
}
inline ::google::protobuf::int32 SchedulerHeartbeatResponse::heartbeat_grace_period() const {
  // @@protoc_insertion_point(field_get:mprs.SchedulerHeartbeatResponse.heartbeat_grace_period)
  return heartbeat_grace_period_;
}
inline void SchedulerHeartbeatResponse::set_heartbeat_grace_period(::google::protobuf::int32 value) {
  
  heartbeat_grace_period_ = value;
  // @@protoc_insertion_point(field_set:mprs.SchedulerHeartbeatResponse.heartbeat_grace_period)
}

// optional int32 lose_unhealthy_worker_after = 4;
inline void SchedulerHeartbeatResponse::clear_lose_unhealthy_worker_after() {
  lose_unhealthy_worker_after_ = 0;
}
inline ::google::protobuf::int32 SchedulerHeartbeatResponse::lose_unhealthy_worker_after() const {
  // @@protoc_insertion_point(field_get:mprs.SchedulerHeartbeatResponse.lose_unhealthy_worker_after)
  return lose_unhealthy_worker_after_;
}
inline void SchedulerHeartbeatResponse::set_lose_unhealthy_worker_after(::google::protobuf::int32 value) {
  
  lose_unhealthy_worker_after_ = value;
  // @@protoc_insertion_point(field_set:mprs.SchedulerHeartbeatResponse.lose_unhealthy_worker_after)
}

// optional int32 worker_check_interval = 5;
inline void SchedulerHeartbeatResponse::clear_worker_check_interval() {
  worker_check_interval_ = 0;
}
inline ::google::protobuf::int32 SchedulerHeartbeatResponse::worker_check_interval() const {
  // @@protoc_insertion_point(field_get:mprs.SchedulerHeartbeatResponse.worker_check_interval)
  return worker_check_interval_;
}
inline void SchedulerHeartbeatResponse::set_worker_check_interval(::google::protobuf::int32 value) {
  
  worker_check_interval_ = value;
  // @@protoc_insertion_point(field_set:mprs.SchedulerHeartbeatResponse.worker_check_interval)
}

// optional int32 worker_state = 6;
inline void SchedulerHeartbeatResponse::clear_worker_state() {
  worker_state_ = 0;
}
inline ::google::protobuf::int32 SchedulerHeartbeatResponse::worker_state() const {
  // @@protoc_insertion_point(field_get:mprs.SchedulerHeartbeatResponse.worker_state)
  return worker_state_;
}
inline void SchedulerHeartbeatResponse::set_worker_state(::google::protobuf::int32 value) {
  
  worker_state_ = value;
  // @@protoc_insertion_point(field_set:mprs.SchedulerHeartbeatResponse.worker_state)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mprs

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mprs::KillMethod> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mprs::KillMethod>() {
  return ::mprs::KillMethod_descriptor();
}
template <> struct is_proto_enum< ::mprs::KilledTaskStatusFilter> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mprs::KilledTaskStatusFilter>() {
  return ::mprs::KilledTaskStatusFilter_descriptor();
}
template <> struct is_proto_enum< ::mprs::MprsTaskStatusBits> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mprs::MprsTaskStatusBits>() {
  return ::mprs::MprsTaskStatusBits_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
